# -*- coding: utf-8 -*-
"""Untitled34.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uWzrVZny02KjyV-dksZKIxUF3pKG9Cag
"""

from flask import Flask, request, send_file, jsonify
from obspy import read
import requests
import io
import datetime
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use('Agg')  # Para evitar problemas de GUI en entornos sin pantalla
from flask_cors import CORS
import logging

# Configuración de estaciones para mostrar información
STATIONS_CONFIG = {
    "UIS01": {"location": "Los Santos,  Colombia-Santander", "channels": ["HNE", "HNN", "HNZ"]},
    "UIS03": {"location": "Málaga,      Colombia-Santander", "channels": ["HNE", "HNN", "HNZ"]},
    "UIS05": {"location": "Esmeralda-Bucaramanga, Colombia", "channels": ["EHZ", "ENE", "ENN", "ENZ"]},
    "UIS04": {"location": "Pamplona,    Colombia-Norte de Santander", "channels": ["HNE", "HNN", "HNZ"]},
    "UIS09": {"location": "Zapatoca,    Colombia-Santander", "channels": ["ENE", "ENN", "ENZ"]},
    "UIS11": {"location": "Chitagá,     Colombia-Norte de Santander", "channels": ["ENE", "ENN", "ENZ"]},
    "UIS10": {"location": "Macaravita,  Colombia-Santander", "channels": ["ENE", "ENN", "ENZ"]},
    "UIS06": {"location": "San Alberto, Colombia-Santander", "channels": ["ENE", "ENN", "ENZ"]}
}


app = Flask(__name__)
CORS(app)  # Habilita CORS para todas las rutas

# Conversión del UTC a hora local Colombia(UTC-5)N
def utc_to_colombia(utc_dt):
    """Convierte un datetime UTC a hora de Colombia (UTC-5)"""
    return utc_dt - datetime.timedelta(hours=5)

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Función auxiliar para calcular la diferencia de tiempo
def calculate_time_difference(start, end):
    try:
        start_time = datetime.datetime.fromisoformat(start)
        end_time = datetime.datetime.fromisoformat(end)
        return (end_time - start_time).total_seconds() / 60  # Diferencia en minutos
    except Exception as e:
        logger.error(f"Error calculando diferencia de tiempo: {str(e)}")
        raise

# Ruta principal para manejar gráficos dinámicamente
@app.route('/generate_graph', methods=['GET'])
def generate_graph():
    try:
        logger.info("Iniciando solicitud /generate_graph")
        
        # Obtener parámetros de la solicitud
        start = request.args.get('start')
        end = request.args.get('end')
        net = request.args.get('net')
        sta = request.args.get('sta')
        loc = request.args.get('loc')
        cha = request.args.get('cha')

        logger.info(f"Parámetros recibidos - start: {start}, end: {end}, net: {net}, sta: {sta}, loc: {loc}, cha: {cha}")

        # Verificar que todos los parámetros estén presentes
        if not all([start, end, net, sta, loc, cha]):
            error_msg = "Faltan parámetros requeridos"
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 400

        # Calcular la diferencia de tiempo para decidir el tipo de gráfico
        try:
            interval_minutes = calculate_time_difference(start, end)
            logger.info(f"Diferencia de tiempo calculada: {interval_minutes} minutos")
        except Exception as e:
            error_msg = f"Error calculando intervalo de tiempo: {str(e)}"
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 400

        if interval_minutes <= 30:
            logger.info("Generando sismograma (intervalo ≤ 30 minutos)")
            return generate_sismograma(net, sta, loc, cha, start, end)
        else:
            logger.info("Generando helicorder (intervalo > 30 minutos)")
            return generate_helicorder(net, sta, loc, cha, start, end)

    except Exception as e:
        error_msg = f"Error inesperado en /generate_graph: {str(e)}"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 500

# Ruta para generar específicamente sismogramas
@app.route('/generate_sismograma', methods=['GET'])
def generate_sismograma_route():
    try:
        logger.info("Iniciando solicitud /generate_sismograma")
        
        # Extraer parámetros de la solicitud
        start = request.args.get('start')
        end = request.args.get('end')
        net = request.args.get('net')
        sta = request.args.get('sta')
        loc = request.args.get('loc')
        cha = request.args.get('cha')

        logger.info(f"Parámetros recibidos - start: {start}, end: {end}, net: {net}, sta: {sta}, loc: {loc}, cha: {cha}")

        # Validar los parámetros
        if not all([start, end, net, sta, loc, cha]):
            error_msg = "Faltan parámetros requeridos"
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 400

        # Llamar a la función de generación de sismogramas
        logger.info("Generando sismograma...")
        return generate_sismograma(net, sta, loc, cha, start, end)

    except Exception as e:
        error_msg = f"Error inesperado en /generate_sismograma: {str(e)}"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 500

# Ruta para generar específicamente helicorders
@app.route('/generate_helicorder', methods=['GET'])
def generate_helicorder_route():
    try:
        logger.info("Iniciando solicitud /generate_helicorder")
        
        # Extraer parámetros de la solicitud
        start = request.args.get('start')
        end = request.args.get('end')
        net = request.args.get('net')
        sta = request.args.get('sta')
        loc = request.args.get('loc')
        cha = request.args.get('cha')

        logger.info(f"Parámetros recibidos - start: {start}, end: {end}, net: {net}, sta: {sta}, loc: {loc}, cha: {cha}")

        # Validar los parámetros
        if not all([start, end, net, sta, loc, cha]):
            error_msg = "Faltan parámetros requeridos"
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 400

        # Llamar a la función de generación de helicorders
        logger.info("Generando helicorder...")
        return generate_helicorder(net, sta, loc, cha, start, end)

    except Exception as e:
        error_msg = f"Error inesperado en /generate_helicorder: {str(e)}"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 500

# Función para generar un sismograma
def generate_sismograma(net, sta, loc, cha, start, end):
    try:
        logger.info(f"Generando sismograma para: {net}.{sta}.{loc}.{cha}, {start} - {end}")
        
        # Construir la URL para descargar datos
        url = f"http://osso.univalle.edu.co/fdsnws/dataselect/1/query?starttime={start}&endtime={end}&network={net}&station={sta}&location={loc}&channel={cha}&nodata=404"
        logger.info(f"URL construida: {url}")
        
        # Realizar la solicitud al servidor remoto
        logger.info("Realizando solicitud HTTP...")
        response = requests.get(url, timeout=30)
        
        if response.status_code != 200:
            error_msg = f"Error al descargar datos: {response.status_code}"
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 500

        logger.info(f"Datos descargados correctamente, tamaño: {len(response.content)} bytes")

        # Procesar los datos MiniSEED
        mini_seed_data = io.BytesIO(response.content)
        try:
            logger.info("Procesando datos MiniSEED...")
            st = read(mini_seed_data)
            logger.info(f"Datos MiniSEED procesados correctamente. Número de trazas: {len(st)}")
        except Exception as e:
            error_msg = f"Error procesando MiniSEED: {str(e)}"
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 500

        # Crear gráfico del sismograma
        tr = st[0]
        start_time = tr.stats.starttime.datetime
        times = [start_time + datetime.timedelta(seconds=sec) for sec in tr.times()]
        data = tr.data

        logger.info("Generando gráfico del sismograma...")
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(times, data, color='black', linewidth=0.8)
        ax.set_title(f"Universidad Industrial de Santander UIS\nRed Sísmica REDNE\n{start} - {end}")
        
        #Información de estación y canal, Buscar la ubicación de la estación
        station_location = STATIONS_CONFIG.get(sta, {}).get("location", "Ubicación desconocida")
        # Texto a mostrar
        est_info = f"Estación: {sta} - Canal: {cha}\n{station_location}"
        # Mostrar debajo del título
        ax.text(0.5, 1.02, est_info, transform=ax.transAxes, fontsize=11, ha='center', va='bottom', color='navy')
        # 
        

        ax.set_xlabel("Tiempo (UTC Colombia)")
        ax.set_ylabel("Amplitud (M/s)")
        fig.autofmt_xdate()

        # Mostrar tiempo UTC Colombia debajo del eje X, Convertir a datetime los strings de inicio y fin
        start_dt = datetime.datetime.fromisoformat(start)
        end_dt = datetime.datetime.fromisoformat(end)
        # Convertir a hora Colombia
        start_col = utc_to_colombia(start_dt)
        end_col = utc_to_colombia(end_dt)
        # Texto a mostrar
        utc_col_text = f"Tiempo Colombia (UTC-5): {start_col.strftime('%Y-%m-%d %H:%M:%S')} a {end_col.strftime('%Y-%m-%d %H:%M:%S')}"
        # Mostrar debajo del eje X
        fig.text(0.5, 0.01, utc_col_text, ha='center', fontsize=10, color='darkgreen')
        # 

        
        # Agregar información de la estación
        station_info = f"{net}.{sta}.{loc}.{cha}"
        ax.text(0.02, 0.98, station_info, transform=ax.transAxes, 
                fontsize=10, verticalalignment='top', 
                bbox=dict(facecolor='white', edgecolor='black'))

        # Guardar el gráfico en memoria
        output_image = io.BytesIO()
        plt.savefig(output_image, format='png', dpi=100, bbox_inches="tight")
        output_image.seek(0)
        plt.close(fig)
        logger.info("Gráfico del sismograma generado correctamente")

        return send_file(output_image, mimetype='image/png')

    except requests.exceptions.Timeout:
        error_msg = "Tiempo de espera agotado al conectar con el servidor OSSO"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 504
    except requests.exceptions.RequestException as e:
        error_msg = f"Error de conexión: {str(e)}"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 503
    except Exception as e:
        error_msg = f"Error inesperado al generar sismograma: {str(e)}"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 500

# Función para generar un helicorder
def generate_helicorder(net, sta, loc, cha, start, end):
    try:
        logger.info(f"Generando helicorder para: {net}.{sta}.{loc}.{cha}, {start} - {end}")
        
        # Construir la URL para descargar datos
        url = f"http://osso.univalle.edu.co/fdsnws/dataselect/1/query?starttime={start}&endtime={end}&network={net}&station={sta}&location={loc}&channel={cha}&nodata=404"
        logger.info(f"URL construida: {url}")
        
        # Realizar la solicitud al servidor remoto
        logger.info("Realizando solicitud HTTP...")
        response = requests.get(url, timeout=60)  # Mayor timeout para helicorders
        
        if response.status_code != 200:
            error_msg = f"Error al descargar datos: {response.status_code}"
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 500

        logger.info(f"Datos descargados correctamente, tamaño: {len(response.content)} bytes")

        # Procesar los datos MiniSEED
        mini_seed_data = io.BytesIO(response.content)
        try:
            logger.info("Procesando datos MiniSEED...")
            st = read(mini_seed_data)
            logger.info(f"Datos MiniSEED procesados correctamente. Número de trazas: {len(st)}")
        except Exception as e:
            error_msg = f"Error procesando MiniSEED: {str(e)}"
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 500

        # Crear helicorder utilizando ObsPy
        logger.info("Generando gráfico helicorder...")
        fig = st.plot(
            type="dayplot",
            interval=15,
            right_vertical_labels=True,
            vertical_scaling_range=2000,
            color=['k', 'r', 'b'],
            show_y_UTC_label=True,
            one_tick_per_line=True,
            size=(12, 6)
        )

        # Ajustar el tamaño del helicorder
        fig.set_size_inches(12, 4)
        logger.info("Gráfico helicorder generado correctamente")

        # Guardar el gráfico en memoria
        output_image = io.BytesIO()
        fig.savefig(output_image, format='png', dpi=120, bbox_inches="tight")
        output_image.seek(0)
        plt.close(fig)

        return send_file(output_image, mimetype='image/png')

    except requests.exceptions.Timeout:
        error_msg = "Tiempo de espera agotado al conectar con el servidor OSSO"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 504
    except requests.exceptions.RequestException as e:
        error_msg = f"Error de conexión: {str(e)}"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 503
    except Exception as e:
        error_msg = f"Error inesperado al generar helicorder: {str(e)}"
        logger.error(error_msg)
        return jsonify({"error": error_msg}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
